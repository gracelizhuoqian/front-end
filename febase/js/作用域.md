## 作用域

### what？

程序最基础的功能就是存取变量，作用域就是一套用于**约束变量的存取**的规则。（变量存在哪，谁可以访问，什么时候可以访问）  
作用域指变量（函数）的可访问性。  
作用域可以从时间和空间上分别阐释。

**时间**  
变量的生命周期。  
当引擎执行语句时，全局变量一直存在于内存中，只有执行到函数内部时，才会创建内部变量，此时内部变量才有了生命，当函数执行完毕，会销毁这些临时变量。

**空间**  
是不是在任何地方都能访问一些变量呢？非也  
变量的空间作用域取决于其声明的位置，注意是声明的位置而不是调用的位置。我们称为词法作用域。  
同时以函数作为分界来限制变量的可访问性。函数 a 内部定义的函数 b 可以访问其外部（a 函数直至全局）的变量但是反过来不行。

虽然 js 是解释型语言，但是在执行前还是会有编译的这一步，会对代码进行静态分析，提取出变量和函数声明挂在对应函数定义的门口，于是就有了变量提升。  
既然是变量定义的时候就决定了作用域，js 在编译（预解析）阶段就可以确定各个函数和变量的作用域，可以方便进行优化。

### 执行上下文

举个栗子

```js
function a() {
  var aa = 1
  function b(c) {
    var bb = 2
    return bb + c
  }
  b(aa)
}
a()
let c = 3
```

个人理解，执行上下文中包含了以下三个要素：

1. 变量对象（活动对象）  
   在函数内部创建的变量（形参），函数。调用的时候才会激活，也就是运行时产生。

```js
// global vo
global.VO = {
  a: function () {},
  c: 3,
}
// a vo
a.VO = {
  aa: 1,
  b: function () {},
}
// b vo
b.VO = {
  c: 1,
  bb: 2,
}
```

2. 作用域链  
   其实在定义的阶段就已经产生了，该函数定义的位置为起点，可以访问的外部作用域按照空间形成的链。运行时，会把产生的活动对象接到头部。

   ```js
   global.scope = global.VO
   a.scope = global.scope + a.VO
   b.scope = a.scope + b.VO
   ```

3. this  
   不多说了

### 一个特殊的栗子

```js
let f = 0
;(function f() {
  f = 1
  console.log(f)
})()
console.log(f)
/* 
ƒ f() {
  f = 1
  console.log(f)
}
0
*/
```

具名立即执行函数，创建一个特殊的对象作为变量对象，并且有个属性记录函数名字以便在函数内部访问。因此 f 函数内可以访问到自己，但这个属性是只读的，对其赋值不起作用，所以打印的结果还是这个函数。

```js
;(function f() {
  f = 1
})()
console.log(f)
// Uncaught ReferenceError: f is not defined
```

因为这是函数表达式而不是函数声明，执行完后变量销毁，因此对外部的 f 不构成影响。

### 闭包

函数 a 返回了一个函数 b，b 可以访问 a 中的变量，这就是闭包。  
正常 a 函数执行完后其活动对象会被销毁。但是 b 函数还可以被调用，b 函数还可以访问 a 的活动对象，如果 a 的活动对象销毁了，在 b 调用要访问 a 里面定义的变量时咋整？所以这时候 a 的活动对象要长期存在内存中（堆），以备不时之需。

### 从《你不知道的 js》学作用域

#### 作用域是什么

1. js 的编译
   正常的编译可以简单总结成词法分析，语法分析和代码（机器码）生成  
   js 的引擎会在运行前进行预编译  
   预编译的过程中，会利用编译器把变量和函数的声明都挂载到他们对应的函数作用域上  
   运行时候，引擎会向作用域进行询问，声明过的变量拿来用，没声明过的要沿着作用域链往外找

2. 左右变量查找
   =左边是写，=右边是读。  
   非严格模式下，未声明变量写失败会创建全局变量，读失败会报错`Reference Error`  
   严格模式下，都会报错

3. 一个栗子

`var a=0;`  
第一步：编译器在编译（之后立马运行）阶段，解析变量声明`var a`，问当前作用域是否声明过变量`a`，没有的话，就把`a`声明挂在当前作用域上，否则就忽略，当然如果这是个函数声明，就会覆盖之前的变量声明，函数不愧一等公民；  
第二步：引擎在执行的时候，执行由`a=0`生成的变量赋值代码，问作用域是否该变量声明过，有的话就写入值，没有的话就创建全局变量（非严格模式）或者报错（严格）

#### 词法作用域

1. 函数内部变量的嵌套作用域，也就是静态的作用域链条，由函数声明的位置决定，与函数在何处以何种方式被调用无关
2. 只作用于一级标识符。如查找`a.b.c`，会根据词法作用域规则找`a`，找到后属性的查找由对象属性访问规则接手
3. 沿着作用域链查找，会在找到第一个符合要求的变量时停止，因此会产生同名遮蔽（全局变量可以用`window.xx`来访问）
4. 通过`with`和`eval`可以在运行时修改作用域，区别于词法作用域。但是这样不好，本来编译器在编译阶段，就能根据所有声明来构成固定的作用域，便于引擎之后对变量进行查找以及优化查找链路，但是如果有了动态作用域，就会使得运行前作用域不可预测从而无法优化。

#### 函数作用域

1. 隐藏内部实现的意义？  
   软件设计推崇最小特权原则，要最小限度的暴露必要内容；这样一方面可以使结构更加清晰，另一方面可以避免变量被以非预期的方式错误使用了。

2. 怎么解决命名冲突

第三方库，一般会用命名空间。  
另一种是使用模块管理工具，通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。

3. 函数声明和函数表达式

区分的话，就是看`function`关键字在整个函数声明的位置是不是最前面。
函数声明的话，函数名会挂在外部作用域上正常访问；
函数表达式，函数名不能被外部访问，只能在函数内部访问。

```js
;(function foo() {
  // console.log(foo);foo的作用域在函数内部
})()
```

4. 块作用域

- `const/let` 没有变量提升
- `try{}catch(e){console.log(e)}`抛出的错误只能在`catch`中收到
- `with`

#### 提升

原因其实是编译阶段，编译器已经检测到所有的声明然后挂到对应的作用域中了。因此之前相当于所有声明都提升到所在函数的顶部了。  
需要注意的是函数声明优先级更高，同一个标识符分别被声明为变量和函数的时候，函数会是最终声明。  
只有声明本身（变量和函数）会提升，表达式不会。

#### 闭包

上面说了一种典型的情况。闭包是词法作用域的必然结果。

正常情况

```js
function parent() {
  var a = 0
  function child() {
    console.log(a)
  }
  child()
}
```

函数`child`能够访问`parent`的作用域。当内部函数`child`在它定义所在的词法作用域（也就是`parent`内）被调用时，是最正常的情况，但是我们无法观察到闭包。闭包的出现，突破了--在外部无法访问函数内部变量的限制。

```js
function parent() {
  var a = 0
  function childOrg() {
    console.log(a)
  }
  return childOrg
}
const child = parent()
child()
// 0;
```

可以看到外部函数`child`和`childOrg`其实指向同一个函数，因此我们可以在`parent`外部调用，而又因为词法作用域自然可以访问`parent`中的变量。

> 这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。

**闭包的典型应用**——模块
模块实现了一种封装，要求：

1. 有一个包装函数形成被引用的闭包作用域
2. 返回一个引用了作用域的函数

这也是模块系统的基础，现代的模块系统每个文件都相当于一个闭包（1），而导出的 API 则相当于模块提供的公共接口（2）
