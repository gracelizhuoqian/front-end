## 作用域

### what？

作用域指变量（函数）的可访问性。  
作用域可以从时间和空间上分别阐释。

**时间**
变量的生命周期。  
当引擎执行语句时，全局变量一直存在于内存中，只有执行到函数内部时，才会创建内部变量，此时内部变量才有了生命，当函数执行完毕，会销毁这些临时变量。

**空间**
是不是在任何地方都能访问一些变量呢？非也  
变量的空间作用域取决于其声明的位置，注意是声明的位置而不是调用的位置。我们称为词法作用域。  
同时以函数作为分界来限制变量的可访问性。函数 a 内部定义的函数 b 可以访问其外部（a 函数直至全局）的变量但是反过来不行。

虽然 js 是解释型语言，但是在执行前还是会有编译的这一步，会对代码进行静态分析，提取出变量和函数声明挂在对应函数定义的门口，于是就有了变量提升。  
既然是变量定义的时候就决定了作用域，js 在编译（预解析）阶段就可以确定各个函数和变量的作用域，可以方便进行优化。

### 执行上下文

举个栗子

```js
function a() {
  var aa = 1
  function b(c) {
    var bb = 2
    return bb + c
  }
  b(aa)
}
a()
let c = 3
```

个人理解，执行上下文中包含了以下三个要素：

1. 变量对象（活动对象）  
   在函数内部创建的变量（形参），函数。调用的时候才会激活，也就是运行时产生。

```js
// global vo
global.VO = {
  a: function () {},
  c: 3,
}
// a vo
a.VO = {
  aa: 1,
  b: function () {},
}
// b vo
b.VO = {
  c: 1,
  bb: 2,
}
```

2. 作用域链  
   其实在定义的阶段就已经产生了，该函数定义的位置为起点，可以访问的外部作用域按照空间形成的链。运行时，会把产生的活动对象接到头部。

   ```js
   global.scope = global.VO
   a.scope = global.scope + a.VO
   b.scope = a.scope + b.VO
   ```

3. this  
   不多说了

### 一个特殊的栗子

```js
let f = 0
;(function f() {
  f = 1
  console.log(f)
})()
console.log(f)
/* 
ƒ f() {
  f = 1
  console.log(f)
}
0
*/
```

具名立即执行函数，创建一个特殊的对象作为变量对象，并且有个属性记录函数名字以便在函数内部访问。因此 f 函数内可以访问到自己，但这个属性是只读的，对其赋值不起作用，所以打印的结果还是这个函数。

```js
;(function f() {
  f = 1
})()
console.log(f)
// Uncaught ReferenceError: f is not defined
```

因为这是函数表达式而不是函数声明，执行完后变量销毁，因此对外部的 f 不构成影响。
