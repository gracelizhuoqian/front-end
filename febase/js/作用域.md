## 作用域

### what？

程序最基础的功能就是存取变量，作用域就是一套用于**约束变量的存取**的规则。（变量存在哪，谁可以访问，什么时候可以访问）  
作用域指变量（函数）的可访问性。  
作用域可以从时间和空间上分别阐释。

**时间**  
变量的生命周期。  
当引擎执行语句时，全局变量一直存在于内存中，只有执行到函数内部时，才会创建内部变量，此时内部变量才有了生命，当函数执行完毕，会销毁这些临时变量。

**空间**  
是不是在任何地方都能访问一些变量呢？非也  
变量的空间作用域取决于其声明的位置，注意是声明的位置而不是调用的位置。我们称为词法作用域。  
同时以函数作为分界来限制变量的可访问性。函数 a 内部定义的函数 b 可以访问其外部（a 函数直至全局）的变量但是反过来不行。

虽然 js 是解释型语言，但是在执行前还是会有编译的这一步，会对代码进行静态分析，提取出变量和函数声明挂在对应函数定义的门口，于是就有了变量提升。  
既然是变量定义的时候就决定了作用域，js 在编译（预解析）阶段就可以确定各个函数和变量的作用域，可以方便进行优化。

### 执行上下文

举个栗子

```js
function a() {
  var aa = 1
  function b(c) {
    var bb = 2
    return bb + c
  }
  b(aa)
}
a()
let c = 3
```

个人理解，执行上下文中包含了以下三个要素：

1. 变量对象（活动对象）  
   在函数内部创建的变量（形参），函数。调用的时候才会激活，也就是运行时产生。

```js
// global vo
global.VO = {
  a: function () {},
  c: 3,
}
// a vo
a.VO = {
  aa: 1,
  b: function () {},
}
// b vo
b.VO = {
  c: 1,
  bb: 2,
}
```

2. 作用域链  
   其实在定义的阶段就已经产生了，该函数定义的位置为起点，可以访问的外部作用域按照空间形成的链。运行时，会把产生的活动对象接到头部。

   ```js
   global.scope = global.VO
   a.scope = global.scope + a.VO
   b.scope = a.scope + b.VO
   ```

3. this  
   不多说了

### 一个特殊的栗子

```js
let f = 0
;(function f() {
  f = 1
  console.log(f)
})()
console.log(f)
/* 
ƒ f() {
  f = 1
  console.log(f)
}
0
*/
```

具名立即执行函数，创建一个特殊的对象作为变量对象，并且有个属性记录函数名字以便在函数内部访问。因此 f 函数内可以访问到自己，但这个属性是只读的，对其赋值不起作用，所以打印的结果还是这个函数。

```js
;(function f() {
  f = 1
})()
console.log(f)
// Uncaught ReferenceError: f is not defined
```

因为这是函数表达式而不是函数声明，执行完后变量销毁，因此对外部的 f 不构成影响。

### 闭包

函数 a 返回了一个函数 b，b 可以访问 a 中的变量，这就是闭包。  
正常 a 函数执行完后其活动对象会被销毁。但是 b 函数还可以被调用，b 函数还可以访问 a 的活动对象，如果 a 的活动对象销毁了，在 b 调用要访问 a 里面定义的变量时咋整？所以这时候 a 的活动对象要长期存在内存中（堆），以备不时之需。

### 从《你不知道的 js》学作用域

1. js 的编译
   正常的编译可以简单总结成词法分析，语法分析和代码（机器码）生成  
   js 的引擎会在运行前进行预编译  
   预编译的过程中，会利用编译器把变量和函数的声明都挂载到他们对应的函数作用域上  
   运行时候，引擎会向作用域进行询问，声明过的变量拿来用，没声明过的要沿着作用域链往外找

2. 左右变量查找
   =左边是写，=右边是读。  
   非严格模式下，未声明变量写失败会创建全局变量，读失败会报错`Reference Error`  
   严格模式下，都会报错

3. 一个栗子

`var a=0;`
第一步：编译器在编译（之后立马运行）阶段，解析变量声明`var a`，问当前作用域是否声明过变量`a`，没有的话，就把`a`声明挂在当前作用域上，否则就忽略，当然如果这是个函数声明，就会覆盖之前的变量声明，函数不愧一等公民；  
第二步：引擎在执行的时候，执行由`a=0`生成的变量赋值代码，问作用域是否该变量声明过，有的话就写入值，没有的话就创建全局变量（非严格模式）或者报错（严格）
